import os, glob, math, time
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import pydicom
import torch
import torch.nn as nn
import torch.nn.functional as F
from scipy import ndimage as ndi
from scipy.io import loadmat
from rt_utils import RTStructBuilder

# ============================================================
# USER CONFIGURATION (SET VIA ENV VARIABLES IF NEEDED)
# ============================================================

ROOT_DIR     = os.environ.get("LCTSC_ROOT", "./LCTSC")
WEIGHTS_PATH = os.environ.get("WEIGHTS_PATH", "./models/model_best.pth")
TARGET_SHAPE = (128,128,128)
PANEL_PATH   = "lctsc_validation_top5.png"
CLAMP_HU     = (-1000, 400)

# ============================================================
# MODEL (ORIGINAL ARCHITECTURE)
# ============================================================

class DoubleConv(nn.Module):
    def __init__(self,in_ch,out_ch):
        super().__init__()
        self.conv=nn.Sequential(
            nn.Conv3d(in_ch,out_ch,3,padding=1),
            nn.BatchNorm3d(out_ch), nn.ReLU(inplace=True),
            nn.Conv3d(out_ch,out_ch,3,padding=1),
            nn.BatchNorm3d(out_ch), nn.ReLU(inplace=True),
        )
    def forward(self,x): return self.conv(x)

def sine_encoding(x, num_bands=6, base_list=(0.5,1.0,2.0)):
    b,c,d,h,w=x.shape
    z=torch.linspace(-1,1,d,device=x.device)[None,:,None,None].expand(b,d,h,w)
    y=torch.linspace(-1,1,h,device=x.device)[None,None,:,None].expand(b,d,h,w)
    xg=torch.linspace(-1,1,w,device=x.device)[None,None,None,:].expand(b,d,h,w)
    enc=[]
    for base in base_list:
        for k in range(num_bands):
            for fn in (torch.sin, torch.cos):
                s=base*(2.0**k)*math.pi
                enc += [fn(s*xg), fn(s*y), fn(s*z)]
    pe=torch.stack(enc,1)
    if pe.shape[1]>c: pe=pe[:,:c]
    elif pe.shape[1]<c: pe=F.pad(pe,(0,0,0,0,0,0,0,c-pe.shape[1]))
    return x+pe

class UNet3DDeep(nn.Module):
    def __init__(self,in_ch=1,out_ch=3):
        super().__init__()
        self.enc1=DoubleConv(in_ch,32)
        self.enc2=DoubleConv(32,64)
        self.enc3=DoubleConv(64,128)
        self.enc4=DoubleConv(128,256)
        self.pool=nn.MaxPool3d(2)
        self.up3=nn.ConvTranspose3d(256,128,2,2); self.dec3=DoubleConv(256,128)
        self.up2=nn.ConvTranspose3d(128,64,2,2);  self.dec2=DoubleConv(128,64)
        self.up1=nn.ConvTranspose3d(64,32,2,2);   self.dec1=DoubleConv(64,32)
        self.out=nn.Conv3d(32,out_ch,1)

    def forward(self,x):
        x=sine_encoding(x)
        e1=self.enc1(x)
        e2=self.enc2(self.pool(e1))
        e3=self.enc3(self.pool(e2))
        e4=self.enc4(self.pool(e3))
        d3=self.dec3(torch.cat([self.up3(e4),e3],1))
        d2=self.dec2(torch.cat([self.up2(d3),e2],1))
        d1=self.dec1(torch.cat([self.up1(d2),e1],1))
        return self.out(d1)

def build_model(device):
    if not os.path.isfile(WEIGHTS_PATH):
        raise FileNotFoundError(f"Weights not found: {WEIGHTS_PATH}")
    m=UNet3DDeep().to(device).eval()
    state=torch.load(WEIGHTS_PATH,map_location=device)
    m.load_state_dict(state,strict=False)
    return m

# ============================================================
# HELPERS
# ============================================================

def dice_iou(p,t):
    p,t=p.astype(bool),t.astype(bool)
    inter=np.logical_and(p,t).sum()
    dice=(2*inter)/(p.sum()+t.sum()+1e-6)
    iou=inter/((p|t).sum()+1e-6)
    return float(dice), float(iou)

def normalize01(x):
    x=x.astype(np.float32)
    return (x-x.min())/(x.max()-x.min()+1e-8)

def read_dicom_series(folder):
    files=sorted(glob.glob(os.path.join(folder,"*.dcm")))
    slices=[pydicom.dcmread(f) for f in files]
    slices=sorted(slices,key=lambda s: float(s.ImagePositionPatient[2]))
    vol=np.stack([s.pixel_array for s in slices],0).astype(np.float32)
    return vol

def find_pairs(root):
    pairs=[]
    for path,dirs,_ in os.walk(root):
        for d in dirs:
            full=os.path.join(path,d)
            dcm=glob.glob(os.path.join(full,"*.dcm"))
            if len(dcm)>5:
                rt=glob.glob(os.path.join(full,"*.dcm"))
                if rt:
                    pairs.append((full, rt[0]))
    return pairs

# ============================================================
# RUN ALL CASES
# ============================================================

device=torch.device("cuda" if torch.cuda.is_available() else "cpu")
model=build_model(device)

pairs=find_pairs(ROOT_DIR)
results=[]

for ct_dir, rt_path in pairs:

    try:
        vol=read_dicom_series(ct_dir)
        vol=np.clip(vol,*CLAMP_HU)

        t=torch.from_numpy(vol)[None,None].float()
        t_iso=F.interpolate(t,TARGET_SHAPE,mode="trilinear",align_corners=False)
        t_iso=(t_iso-t_iso.mean())/(t_iso.std()+1e-6)
        t_iso=t_iso.to(device)

        with torch.inference_mode():
            logits=model(t_iso)

        pred=torch.argmax(logits,1).squeeze().cpu().numpy()

        rtb=RTStructBuilder.create_from(dicom_series_path=ct_dir,rt_struct_path=rt_path)
        gtR=rtb.get_roi_mask_by_name("Lung_R")
        gtL=rtb.get_roi_mask_by_name("Lung_L")

        gt=np.zeros_like(vol,np.uint8)
        gt[gtL]=1
        gt[gtR]=2

        gt_rs=F.interpolate(torch.from_numpy(gt.astype(np.float32))[None,None],
                            TARGET_SHAPE,mode="nearest").squeeze().numpy().astype(np.uint8)

        dL,iL=dice_iou(pred==1,gt_rs==1)
        dR,iR=dice_iou(pred==2,gt_rs==2)
        macro=(dL+dR)/2

        results.append({
            "name": os.path.basename(ct_dir),
            "macro": macro,
            "dice_L": dL,
            "dice_R": dR,
            "ct": normalize01(t_iso.squeeze()[TARGET_SHAPE[0]//2].cpu().numpy()),
            "pred": pred[TARGET_SHAPE[0]//2]
        })

    except:
        continue

if not results:
    raise SystemExit("No valid validation cases.")

# ============================================================
# FULL COHORT REPORT
# ============================================================

macros=np.array([r["macro"] for r in results])
diceL=np.array([r["dice_L"] for r in results])
diceR=np.array([r["dice_R"] for r in results])

print("\n=== FULL LCTSC VALIDATION ===")
print(f"Cases: {len(results)}")
print(f"Macro Dice: {macros.mean():.3f} ± {macros.std(ddof=1):.3f}")
print(f"Left Dice:  {diceL.mean():.3f}")
print(f"Right Dice: {diceR.mean():.3f}")

# ============================================================
# VISUALISATION
# ============================================================

top5=sorted(results,key=lambda r:r["macro"],reverse=True)[:5]

fig,axes=plt.subplots(len(top5),2,figsize=(8,3*len(top5)))
for i,res in enumerate(top5):
    axes[i,0].imshow(res["ct"],cmap="gray")
    axes[i,0].set_title(f"{res['name']} | CT")
    axes[i,0].axis('off')

    axes[i,1].imshow(res["pred"])
    axes[i,1].set_title(f"Prediction | Dice {res['macro']:.3f}")
    axes[i,1].axis('off')

plt.tight_layout()
plt.savefig(PANEL_PATH,dpi=160)
plt.show()

print(f"\nSaved panel → {os.path.abspath(PANEL_PATH)}")
