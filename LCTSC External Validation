# ==========================================================
# LCTSC External Validation Script
# ==========================================================

import os, glob, math
import numpy as np
import matplotlib.pyplot as plt
import pydicom
import torch
import torch.nn as nn
import torch.nn.functional as F
from scipy import ndimage as ndi
from rt_utils import RTStructBuilder

# ==========================================================
# CONFIG 
# ==========================================================

ROOT_DIR     = os.environ.get("LCTSC_ROOT", "./LCTSC")
WEIGHTS_PATH = os.environ.get("WEIGHTS_PATH", "./models/model_best.pth")
TARGET_SHAPE = (128,128,128)
PANEL_PATH   = "lctsc_validation_top5.png"
CLAMP_HU     = (-1000, 400)

# ==========================================================
# MODEL 
# ==========================================================

class DoubleConv(nn.Module):
    def __init__(self,in_ch,out_ch):
        super().__init__()
        self.net = nn.Sequential(
            nn.Conv3d(in_ch,out_ch,3,padding=1),
            nn.BatchNorm3d(out_ch), nn.ReLU(inplace=True),
            nn.Conv3d(out_ch,out_ch,3,padding=1),
            nn.BatchNorm3d(out_ch), nn.ReLU(inplace=True),
        )
    def forward(self,x): return self.net(x)

def sine_encoding(x, num_bands=6, base_list=(0.5,1.0,2.0)):
    b,c,d,h,w=x.shape
    z=torch.linspace(-1,1,d,device=x.device)[None,:,None,None].expand(b,d,h,w)
    y=torch.linspace(-1,1,h,device=x.device)[None,None,:,None].expand(b,d,h,w)
    xg=torch.linspace(-1,1,w,device=x.device)[None,None,None,:].expand(b,d,h,w)
    enc=[]
    for base in base_list:
        for k in range(num_bands):
            for fn in (torch.sin, torch.cos):
                s=base*(2.0**k)*math.pi
                enc += [fn(s*xg), fn(s*y), fn(s*z)]
    pe=torch.stack(enc,1)
    if pe.shape[1]>c: pe=pe[:,:c]
    elif pe.shape[1]<c: pe=F.pad(pe,(0,0,0,0,0,0,0,c-pe.shape[1]))
    return x+pe

class UNet3DDeep(nn.Module):
    def __init__(self,in_ch=1,out_ch=3):
        super().__init__()
        self.pool=nn.MaxPool3d(2)

        self.enc1=DoubleConv(in_ch,32)
        self.enc2=DoubleConv(32,64)
        self.enc3=DoubleConv(64,128)
        self.enc4=DoubleConv(128,256)

        self.bottleneck=DoubleConv(256,512)

        self.up4=nn.ConvTranspose3d(512,256,2,2)
        self.dec4=DoubleConv(512,256)

        self.up3=nn.ConvTranspose3d(256,128,2,2)
        self.dec3=DoubleConv(256,128)

        self.up2=nn.ConvTranspose3d(128,64,2,2)
        self.dec2=DoubleConv(128,64)

        self.up1=nn.ConvTranspose3d(64,32,2,2)
        self.dec1=DoubleConv(64,32)

        self.out=nn.Conv3d(32,out_ch,1)

    def forward(self,x):
        x=sine_encoding(x)
        e1=self.enc1(x)
        e2=self.enc2(self.pool(e1))
        e3=self.enc3(self.pool(e2))
        e4=self.enc4(self.pool(e3))

        b=self.bottleneck(self.pool(e4))

        d4=self.dec4(torch.cat([self.up4(b),e4],1))
        d3=self.dec3(torch.cat([self.up3(d4),e3],1))
        d2=self.dec2(torch.cat([self.up2(d3),e2],1))
        d1=self.dec1(torch.cat([self.up1(d2),e1],1))

        return self.out(d1)

# ==========================================================
# HELPERS
# ==========================================================

def dice_iou(p,t):
    p,t=p.astype(bool),t.astype(bool)
    inter=np.logical_and(p,t).sum()
    dice=(2*inter)/(p.sum()+t.sum()+1e-6)
    iou=inter/((p|t).sum()+1e-6)
    return float(dice), float(iou)

def normalize01(x):
    x=x.astype(np.float32)
    return (x-x.min())/(x.max()-x.min()+1e-8)

def read_ct_series(folder):
    files=sorted(glob.glob(os.path.join(folder,"*.dcm")))
    slices=[pydicom.dcmread(f) for f in files]
    slices=sorted(slices,key=lambda s: float(s.ImagePositionPatient[2]))
    vol=np.stack([s.pixel_array for s in slices],0).astype(np.float32)
    return vol

def find_ct_rt_pairs(root):
    pairs=[]
    for root_path, dirs, _ in os.walk(root):
        ct_dirs=[]
        rt_files=[]
        for d in dirs:
            full=os.path.join(root_path,d)
            dcm=glob.glob(os.path.join(full,"*.dcm"))
            if not dcm: continue
            ds=pydicom.dcmread(dcm[0], stop_before_pixels=True, force=True)
            if getattr(ds,"Modality","")=="RTSTRUCT":
                rt_files.append(os.path.join(full,os.path.basename(dcm[0])))
            elif getattr(ds,"Modality","")=="CT":
                ct_dirs.append(full)
        if ct_dirs and rt_files:
            pairs.append((ct_dirs[0], rt_files[0]))
    return pairs

# ==========================================================
# RUN VALIDATION
# ==========================================================

device=torch.device("cuda" if torch.cuda.is_available() else "cpu")
model=UNet3DDeep().to(device).eval()

if not os.path.isfile(WEIGHTS_PATH):
    raise FileNotFoundError("Model weights not found.")

state=torch.load(WEIGHTS_PATH,map_location=device)
model.load_state_dict(state,strict=True)

pairs=find_ct_rt_pairs(ROOT_DIR)
if not pairs:
    raise SystemExit("No CT–RTSTRUCT pairs found.")

results=[]

for ct_dir, rt_path in pairs:
    try:
        vol=read_ct_series(ct_dir)
        vol=np.clip(vol,*CLAMP_HU)

        t=torch.from_numpy(vol)[None,None].float()
        t_iso=F.interpolate(t,TARGET_SHAPE,mode="trilinear",align_corners=False)
        t_iso=(t_iso-t_iso.mean())/(t_iso.std()+1e-6)
        t_iso=t_iso.to(device)

        with torch.inference_mode():
            logits=model(t_iso)

        pred=torch.argmax(logits,1).squeeze().cpu().numpy()

        rtb=RTStructBuilder.create_from(
            dicom_series_path=ct_dir,
            rt_struct_path=rt_path
        )

        gtR=rtb.get_roi_mask_by_name("Lung_R")
        gtL=rtb.get_roi_mask_by_name("Lung_L")

        gt=np.zeros_like(vol,np.uint8)
        gt[gtL]=1
        gt[gtR]=2

        gt_rs=F.interpolate(
            torch.from_numpy(gt.astype(np.float32))[None,None],
            TARGET_SHAPE,mode="nearest"
        ).squeeze().numpy().astype(np.uint8)

        dL,_=dice_iou(pred==1,gt_rs==1)
        dR,_=dice_iou(pred==2,gt_rs==2)
        macro=(dL+dR)/2

        results.append({
            "name": os.path.basename(ct_dir),
            "macro": macro,
            "dice_L": dL,
            "dice_R": dR,
            "ct": normalize01(t_iso.squeeze()[TARGET_SHAPE[0]//2].cpu().numpy()),
            "pred": pred[TARGET_SHAPE[0]//2]
        })

    except Exception as e:
        print("Skipping:", e)

if not results:
    raise SystemExit("No valid validation cases.")

# ==========================================================
# REPORT
# ==========================================================

macros=np.array([r["macro"] for r in results])
print("\n=== LCTSC External Validation ===")
print(f"Cases: {len(results)}")
print(f"Macro Dice: {macros.mean():.3f} ± {macros.std(ddof=1):.3f}")

# ==========================================================
# PANEL
# ==========================================================

top5=sorted(results,key=lambda r:r["macro"],reverse=True)[:5]

fig,axes=plt.subplots(len(top5),2,figsize=(8,3*len(top5)))
for i,res in enumerate(top5):
    axes[i,0].imshow(res["ct"],cmap="gray")
    axes[i,0].set_title(f"{res['name']} | CT")
    axes[i,0].axis('off')

    axes[i,1].imshow(res["pred"])
    axes[i,1].set_title(f"Prediction | Dice {res['macro']:.3f}")
    axes[i,1].axis('off')

plt.tight_layout()
plt.savefig(PANEL_PATH,dpi=160)
plt.show()

print(f"\nSaved panel → {os.path.abspath(PANEL_PATH)}")
