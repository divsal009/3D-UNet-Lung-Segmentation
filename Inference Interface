import os, time, glob, math
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from scipy.io import loadmat
import ipywidgets as W
from IPython.display import display

# ============================
# USER CONFIGURATION
# ============================

WEIGHTS_PATH = os.environ.get("WEIGHTS_PATH", os.path.join(".", "models", "model_best.pth"))
SAVE_DIR = os.environ.get("SAVE_DIR", os.path.join(".", "seg_outputs"))
TARGET_SHAPES = (96, 128, 160, 192)

# ============================
# MODEL (ORIGINAL 32→64→128→256)
# ============================

class DoubleConv(nn.Module):
    def __init__(self, in_ch, out_ch):
        super().__init__()
        self.conv = nn.Sequential(
            nn.Conv3d(in_ch, out_ch, 3, padding=1),
            nn.BatchNorm3d(out_ch), nn.ReLU(inplace=True),
            nn.Conv3d(out_ch, out_ch, 3, padding=1),
            nn.BatchNorm3d(out_ch), nn.ReLU(inplace=True),
        )
    def forward(self, x):
        return self.conv(x)

def sine_encoding(x, num_bands=6, base_list=(0.5,1.0,2.0)):
    b,c,d,h,w = x.shape
    z = torch.linspace(-1,1,d,device=x.device)[None,:,None,None].expand(b,d,h,w)
    y = torch.linspace(-1,1,h,device=x.device)[None,None,:,None].expand(b,d,h,w)
    xg= torch.linspace(-1,1,w,device=x.device)[None,None,None,:].expand(b,d,h,w)
    enc=[]
    for base in base_list:
        for k in range(num_bands):
            for fn in (torch.sin, torch.cos):
                s = base*(2.0**k)*math.pi
                enc += [fn(s*xg), fn(s*y), fn(s*z)]
    pe=torch.stack(enc,1)
    if pe.shape[1]>c:
        pe=pe[:,:c]
    elif pe.shape[1]<c:
        pe=F.pad(pe,(0,0,0,0,0,0,0,c-pe.shape[1]))
    return x+pe

class UNet3DDeep(nn.Module):
    def __init__(self, in_ch=1, out_ch=3):
        super().__init__()
        self.enc1=DoubleConv(in_ch,32)
        self.enc2=DoubleConv(32,64)
        self.enc3=DoubleConv(64,128)
        self.enc4=DoubleConv(128,256)
        self.pool=nn.MaxPool3d(2)
        self.up3=nn.ConvTranspose3d(256,128,2,2)
        self.dec3=DoubleConv(256,128)
        self.up2=nn.ConvTranspose3d(128,64,2,2)
        self.dec2=DoubleConv(128,64)
        self.up1=nn.ConvTranspose3d(64,32,2,2)
        self.dec1=DoubleConv(64,32)
        self.out=nn.Conv3d(32,out_ch,1)

    def forward(self,x):
        x=sine_encoding(x)
        e1=self.enc1(x)
        e2=self.enc2(self.pool(e1))
        e3=self.enc3(self.pool(e2))
        e4=self.enc4(self.pool(e3))
        d3=self.dec3(torch.cat([self.up3(e4),e3],1))
        d2=self.dec2(torch.cat([self.up2(d3),e2],1))
        d1=self.dec1(torch.cat([self.up1(d2),e1],1))
        return self.out(d1)

# ============================
# HELPERS
# ============================

def load_ct(path):
    md=loadmat(path)
    return md["imagingData"][0,0]["dataVolume"]

def build_model(device):
    if not os.path.isfile(WEIGHTS_PATH):
        raise FileNotFoundError(f"Weights not found: {WEIGHTS_PATH}")
    model=UNet3DDeep().to(device).eval()
    state=torch.load(WEIGHTS_PATH,map_location=device)
    model.load_state_dict(state,strict=False)
    return model

def pick_device(choice):
    if choice=="cpu":
        return torch.device("cpu")
    if choice=="cuda" and torch.cuda.is_available():
        return torch.device("cuda")
    if choice=="auto" and torch.cuda.is_available():
        return torch.device("cuda")
    return torch.device("cpu")

# ============================
# UI
# ============================

try:
    from ipyfilechooser import FileChooser
    HAS_CHOOSER=True
except:
    HAS_CHOOSER=False

if HAS_CHOOSER:
    fc_ct=FileChooser(os.getcwd()); fc_ct.title="Select CT .mat"
    fc_dir=FileChooser(os.getcwd(),select_default=True,show_only_dirs=True)
else:
    fc_ct=fc_dir=None

batch_cb=W.Checkbox(value=False,description="Batch mode")
shape_dd=W.Dropdown(options=[(f"{n}³",(n,n,n)) for n in TARGET_SHAPES],
                    value=(128,128,128),description="Resample")
dev_dd=W.Dropdown(options=[("Auto","auto"),("CPU","cpu"),("GPU","cuda")],
                  value="auto",description="Device")
run_btn=W.Button(description="Run",button_style="success")
msg=W.HTML("")

if HAS_CHOOSER:
    display(batch_cb,fc_dir,fc_ct,shape_dd,dev_dd,run_btn,msg)
else:
    display(W.HTML("Install ipyfilechooser."),batch_cb,shape_dd,dev_dd,run_btn,msg)

# ============================
# EXECUTION
# ============================

def _run(_):

    device=pick_device(dev_dd.value)

    try:
        model=build_model(device)
    except Exception as e:
        msg.value=str(e)
        return

    os.makedirs(SAVE_DIR,exist_ok=True)

    if batch_cb.value and HAS_CHOOSER:

        folder=fc_dir.selected_path
        if not folder or not os.path.isdir(folder):
            msg.value="Select valid folder."
            return

        files=sorted(glob.glob(os.path.join(folder,"*.mat")))
        if not files:
            msg.value="No .mat files found."
            return

        for idx,path in enumerate(files):
            case_name=f"sample_{idx+1}"
            vol=load_ct(path)

            t=torch.tensor(vol).float().unsqueeze(0).unsqueeze(0)
            t=F.interpolate(t,shape_dd.value,mode="trilinear",align_corners=False)
            t=(t-t.mean())/(t.std()+1e-6)
            t=t.to(device)

            with torch.inference_mode():
                logits=model(t)

            pred=torch.argmax(torch.softmax(logits,1),1).squeeze().cpu().numpy()
            np.save(os.path.join(SAVE_DIR,f"{case_name}.npy"),pred)

        msg.value="Batch complete."

    else:

        if not HAS_CHOOSER or not fc_ct.selected:
            msg.value="Select CT file."
            return

        vol=load_ct(fc_ct.selected)

        t=torch.tensor(vol).float().unsqueeze(0).unsqueeze(0)
        t=F.interpolate(t,shape_dd.value,mode="trilinear",align_corners=False)
        t=(t-t.mean())/(t.std()+1e-6)
        t=t.to(device)

        with torch.inference_mode():
            logits=model(t)

        pred=torch.argmax(torch.softmax(logits,1),1).squeeze().cpu().numpy()
        np.save(os.path.join(SAVE_DIR,"sample.npy"),pred)

        msg.value="Segmentation complete."

run_btn.on_click(_run)

print("Select CT or enable batch mode, then click Run.")
print(f"Weights path: {WEIGHTS_PATH}")
